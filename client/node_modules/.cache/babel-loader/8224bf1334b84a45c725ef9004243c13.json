{"ast":null,"code":"import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cacheGet, cacheSet } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\n\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n  const pageCountKey = `_swr_page_count_` + pageKey;\n  const pageOffsetKey = `_swr_page_offset_` + pageKey;\n  const [pageCount, setPageCount] = useState(cacheGet(pageCountKey) || 1);\n  const [pageOffsets, setPageOffsets] = useState(cacheGet(pageOffsetKey) || [null]);\n  const [pageSWRs, setPageSWRs] = useState([]);\n  const pageCacheRef = useRef([]);\n  const pageFnRef = useRef(pageFn);\n  const emptyPageRef = useRef(false); // Page component (wraps `pageFn`)\n  // for performance reason we need to memorize it\n\n  const Page = useCallback(props => {\n    // render the page component\n    const dataList = pageFnRef.current(props); // if dataList is [], we can assume this page is empty\n    // TODO: this API is not stable\n\n    if (dataList && !dataList.length) {\n      emptyPageRef.current = true;\n    } else {\n      emptyPageRef.current = false;\n    }\n\n    return dataList;\n  }, []); // Doesn't have a next page\n\n  const isReachingEnd = pageOffsets[pageCount] === null;\n  const isLoadingMore = pageCount === pageOffsets.length;\n  const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n  const loadMore = useCallback(() => {\n    if (isLoadingMore || isReachingEnd) return;\n    setPageCount(c => {\n      cacheSet(pageCountKey, c + 1);\n      return c + 1;\n    });\n  }, [isLoadingMore || isReachingEnd]);\n\n  const _pageFn = useCallback(pageFn, deps);\n\n  pageFnRef.current = _pageFn;\n  const pages = useMemo(() => {\n    const getWithSWR = id => swr => {\n      if (!pageSWRs[id] || pageSWRs[id].data !== swr.data || pageSWRs[id].error !== swr.error || pageSWRs[id].revalidate !== swr.revalidate) {\n        setPageSWRs(swrs => {\n          const _swrs = [...swrs];\n          _swrs[id] = {\n            data: swr.data,\n            error: swr.error,\n            revalidate: swr.revalidate,\n            isValidating: swr.isValidating\n          };\n          return _swrs;\n        });\n\n        if (typeof swr.data !== 'undefined') {\n          // set next page's offset\n          const newPageOffset = SWRToOffset(swr, id);\n\n          if (pageOffsets[id + 1] !== newPageOffset) {\n            setPageOffsets(arr => {\n              const _arr = [...arr];\n              _arr[id + 1] = newPageOffset;\n              cacheSet(pageOffsetKey, _arr);\n              return _arr;\n            });\n          }\n        }\n      }\n\n      return swr;\n    }; // render each page\n\n\n    const p = [];\n    const pageCache = pageCacheRef.current;\n\n    for (let i = 0; i < pageCount; ++i) {\n      if (!pageCache[i] || pageCache[i].offset !== pageOffsets[i] || pageCache[i].pageFn !== _pageFn) {\n        // when props change or at init\n        // render the page and cache it\n        pageCache[i] = {\n          component: React.createElement(Page, {\n            key: `page-${pageOffsets[i]}-${i}`,\n            offset: pageOffsets[i],\n            withSWR: getWithSWR(i)\n          }),\n          pageFn: _pageFn,\n          offset: pageOffsets[i]\n        };\n      }\n\n      p.push(pageCache[i].component);\n    }\n\n    return p;\n  }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n  return {\n    pages,\n    pageCount,\n    pageSWRs,\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  };\n}","map":{"version":3,"sources":["/home/odin/Dev/lern/node_modules/swr/esm/use-swr-pages.js"],"names":["React","useCallback","useMemo","useState","useRef","cacheGet","cacheSet","useSWRPages","pageKey","pageFn","SWRToOffset","deps","pageCountKey","pageOffsetKey","pageCount","setPageCount","pageOffsets","setPageOffsets","pageSWRs","setPageSWRs","pageCacheRef","pageFnRef","emptyPageRef","Page","props","dataList","current","length","isReachingEnd","isLoadingMore","isEmpty","loadMore","c","_pageFn","pages","getWithSWR","id","swr","data","error","revalidate","swrs","_swrs","isValidating","newPageOffset","arr","_arr","p","pageCache","i","offset","component","createElement","key","withSWR","push"],"mappings":"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","sourcesContent":["import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cacheGet, cacheSet } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n    const pageCountKey = `_swr_page_count_` + pageKey;\n    const pageOffsetKey = `_swr_page_offset_` + pageKey;\n    const [pageCount, setPageCount] = useState(cacheGet(pageCountKey) || 1);\n    const [pageOffsets, setPageOffsets] = useState(cacheGet(pageOffsetKey) || [null]);\n    const [pageSWRs, setPageSWRs] = useState([]);\n    const pageCacheRef = useRef([]);\n    const pageFnRef = useRef(pageFn);\n    const emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    const Page = useCallback(props => {\n        // render the page component\n        const dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    const isReachingEnd = pageOffsets[pageCount] === null;\n    const isLoadingMore = pageCount === pageOffsets.length;\n    const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    const loadMore = useCallback(() => {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(c => {\n            cacheSet(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    const _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    const pages = useMemo(() => {\n        const getWithSWR = id => swr => {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                setPageSWRs(swrs => {\n                    const _swrs = [...swrs];\n                    _swrs[id] = {\n                        data: swr.data,\n                        error: swr.error,\n                        revalidate: swr.revalidate,\n                        isValidating: swr.isValidating\n                    };\n                    return _swrs;\n                });\n                if (typeof swr.data !== 'undefined') {\n                    // set next page's offset\n                    const newPageOffset = SWRToOffset(swr, id);\n                    if (pageOffsets[id + 1] !== newPageOffset) {\n                        setPageOffsets(arr => {\n                            const _arr = [...arr];\n                            _arr[id + 1] = newPageOffset;\n                            cacheSet(pageOffsetKey, _arr);\n                            return _arr;\n                        });\n                    }\n                }\n            }\n            return swr;\n        };\n        // render each page\n        const p = [];\n        const pageCache = pageCacheRef.current;\n        for (let i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: `page-${pageOffsets[i]}-${i}`, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages,\n        pageCount,\n        pageSWRs,\n        isLoadingMore,\n        isReachingEnd,\n        isEmpty,\n        loadMore\n    };\n}\n"]},"metadata":{},"sourceType":"module"}